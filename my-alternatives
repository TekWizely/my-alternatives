#!/usr/bin/env bash
set -Eeuo pipefail
umask 077 # We use tmp files. Try to protect the user

VERSION="v0.5.0"

function usage() {
	cat <<-USAGE
		my-alternatives - locally-scoped alternatives (${VERSION})
		usage:
		  eval "\$( my-alternatives init )"
		    create and initialize a new (random) alt root for the current shell session
		  eval "\$( my-alternatives init <alt_root> )"
		    create and initialize the specified alt root
		  eval "\$( my-alternatives shellenv [alt_root] )"
		    configure shell session for an existing my-alternatives root (ie ~/.my-alts)
		  my-alternatives config <name>
		    configure an alternative
		  my-alternatives version
		    display version number
		  my-alternatives help <init|shellenv|config>
		    learn more about a specific command

	USAGE
	exit 2
}

function version() {
	printf "%s\n" "${VERSION}"
}

function main() {

	# Bail early if no args
	#
	[ -z "${1:-}" ] && usage

	case "${1}" in
		-h | --help)
			usage
			;;
		help)
			shift
			case "${1:-}" in
				init)
					help_init
					;;
				shellenv)
					help_shellenv
					;;
				config)
					help_config
					;;
				version)
					version
					;;
				*)
					usage
					;;
			esac
			;;
		init)
			shift
			do_init "$@"
			;;
		shellenv)
			shift
			do_shellenv "$@"
			;;
		config)
			shift
			do_config "$@"
			;;
		version)
			version
			;;
		*)
			printf "my-alternatives: error: unrecognized command: %s\n" "${1}" >&2
			printf "use 'my-alternatives --help' for usage\n" >&2
			exit 2
			;;
	esac
}

function help_init() {
	cat <<-'USAGE'
		usage: eval "$(my-alternatives init [--shell <shell>] [alt_root])"

		  Creates and initializes an alt root.

		  When [alt_root] is NOT provided, uses 'mktemp' to generate a
		  temporary directory.

		  Stores the alt root value in MY_ALTS_ROOT

		  Initializes the alt root via:
		     mkdir -p "${MY_ALTS_ROOT}/bin" "${MY_ALTS_ROOT}/man"

		  Finally, configures PATH, and MANPATH.

		  When [--shell <shell>] is NOT provided, checks $SHELL.
		  NOTE: Currently only 'bash' is supported.

		example:

		  $ my-alternatives init

		  export MY_ALTS_ROOT="/tmp/my-alts.abcd"
		  export PATH="${MY_ALTS_ROOT}/bin${PATH:+:$PATH}"
		  export MANPATH="${MY_ALTS_ROOT}/man:${MANPATH:-}"

	USAGE
	exit 2
}

function do_init() {
	local alt_root shell
	while (($#)); do
		case "${1}" in
			--shell)
				if [ -z "${2:-}" ]; then
					printf "my-alternatives: error: no value provided for --shell option. see 'my-alternatives help init' for usage\n" >&2
					exit 2
				fi
				# basename as a courtesy in case they use $SHELL/etc
				#
				shell="$(basename "${2}")"
				shift 2
				;;
			*)
				# If alt_root already defined
				#
				if [ -n "${alt_root:-}" ]; then
					printf "my-alternatives: error: unrecognized option: %s.  see 'my-alternatives help init' for usage\n" "${1}" >&2
					exit 2
				fi
				alt_root="${1}"
				shift
				;;
		esac
	done

	# If --shell not provided, check $SHELL
	#
	if [ -z "${shell:-}" ]; then
		shell="$(basename "${SHELL:-}")"
		if [ -z "${shell}" ]; then
			printf "my-alternatives: error: Unable to determine shell.  see 'my-alternatives help init' for usage\n" >&2
			exit 2
		fi
	fi
	# Confirm shell supported
	#
	if [[ "${shell}" != "bash" ]]; then
		printf "my-alternatives: error: unrecognized shell: %s.  see 'my-alternatives help init' for usage\n" "${1}" >&2
		exit 2
	fi

	if [ -z "${alt_root:-}" ]; then
		if ! alt_root="$(command mktemp -q -d -t my-alts.XXXXXXXX)"; then
			printf "my-alternatives: error: could not create alt_root\n" >&2
			exit 2
		fi
	fi
	# Make dirs - If error, warn but continue
	#
	if ! command mkdir -p "${alt_root}/bin" "${alt_root}/man"; then
		printf "my-alternatives: warning: could not initialize alt_root: %s\n" "${alt_root}" >&2
	fi
	unset MY_ALTS_ROOT
	do_shellenv "--shell" "${shell}" "${alt_root}"
}

function help_shellenv() {
	cat <<-'USAGE'
		usage: eval "$(my-alternatives shellenv [--shell <shell>] [alt_root])"

		  Configures the current session for an existing alt root.
		  You provide it the alt root location, and it then updates
		  MY_ALTS_ROOT, PATH, and MANPATH.

		  This can be handy if you want a long-lived (multi-shell-session)
		  root.

		  When [alt_root] is NOT provided, checks $MY_ALTS_ROOT.

		  When [--shell <shell>] is NOT provided, checks $SHELL.
		  NOTE: Currently only 'bash' is supported.

		example:

		  # Create a long-lived alt root in your home folder
		  $ my-alternatives shellenv ~/.my-alts

		  export MY_ALTS_ROOT="/home/user/.my-alts"
		  export PATH="${MY_ALTS_ROOT}/bin${PATH:+:$PATH}"
		  export MANPATH="${MY_ALTS_ROOT}/man:${MANPATH:-}"

		you can also set MY_ALTS_ROOT manually and have my-alternatives use it:

		  # If no value provided, checks $MY_ALTS_ROOT
		  $ export MY_ALTS_ROOT=~/.my-alts
		  $ my-alternatives shellenv

		  # notice: MY_ALTS_ROOT already defined : /home/user/.my-alts
		  export PATH="${MY_ALTS_ROOT}/bin${PATH:+:$PATH}"
		  export MANPATH="${MY_ALTS_ROOT}/man:${MANPATH:-}"

	USAGE
	exit 2
}

function do_shellenv() {
	local alt_root shell
	while (($#)); do
		case "${1}" in
			--shell)
				if [ -z "${2:-}" ]; then
					printf "my-alternatives: error: no value provided for --shell option. see 'my-alternatives help shellenv' for usage\n" >&2
					exit 2
				fi
				# basename as a courtesy in case they use $SHELL/etc
				#
				shell="$(basename "${2}")"
				shift 2
				;;
			*)
				# If alt_root already defined
				#
				if [ -n "${alt_root:-}" ]; then
					printf "my-alternatives: error: unrecognized option: %s.  see 'my-alternatives help shellenv' for usage\n" "${1}" >&2
					exit 2
				fi
				alt_root="${1}"
				shift
				;;
		esac
	done

	# If --shell not provided, check $SHELL
	#
	if [ -z "${shell:-}" ]; then
		shell="$(basename "${SHELL:-}")"
		if [ -z "${shell}" ]; then
			printf "my-alternatives: error: Unable to determine shell.  see 'my-alternatives help shellenv' for usage\n" >&2
			exit 2
		fi
	fi
	# Confirm shell supported
	#
	if [[ "${shell}" != "bash" ]]; then
		printf "my-alternatives: error: unrecognized shell: %s.  see 'my-alternatives help shellenv' for usage\n" "${1}" >&2
		exit 2
	fi

	if [ -n "${alt_root:-}" ]; then
		if [[ "${alt_root}" == "${MY_ALTS_ROOT:-}" ]]; then
			printf '# my-alternatives: notice: MY_ALTS_ROOT already defined: %s (Re-exporting for completeness)\n' "${MY_ALTS_ROOT}"
		else
			MY_ALTS_ROOT="${alt_root}"
		fi
	else
		if [[ -z "${MY_ALTS_ROOT:-}" ]]; then
			printf "my-alternatives: error: MY_ALTS_ROOT not defined or provided.  see 'my-alternatives help' for usage\n" >&2
			exit 2
		else
			printf '# my-alternatives: notice: MY_ALTS_ROOT already defined: %s (Re-exporting for completeness)\n' "${MY_ALTS_ROOT}"
		fi
	fi
	# If we make it here, we intend to export MY_ALTS_ROOT
	#
	printf 'export MY_ALTS_ROOT="%s"\n' "${MY_ALTS_ROOT}"
	if [ ! -d "${MY_ALTS_ROOT}" ]; then
		printf "# my-alternatives: warning: MY_ALTS_ROOT directory does not (yet) exist: %s\n" "${MY_ALTS_ROOT}" # STDOUT
	fi
	#
	# bin
	#
	if is_dir_in_path "${PATH}" "${MY_ALTS_ROOT}/bin"; then
		printf "# my-alternatives: notice: MY_ALTS_ROOT/bin already in PATH\n"
	else
		# shellcheck disable=SC2016 # don't want to expand expression
		printf 'export PATH="${MY_ALTS_ROOT}/bin${PATH:+:$PATH}"\n'
	fi
	if [ ! -d "${MY_ALTS_ROOT}/bin" ]; then
		printf "# my-alternatives: warning: MY_ALTS_ROOT/bin directory does not (yet) exist: %s\n" "${MY_ALTS_ROOT}/bin" # STDOUT
	fi
	#
	# man
	#
	if is_dir_in_path "${MANPATH:-}" "${MY_ALTS_ROOT}/man"; then
		printf "# notice: MY_ALTS_ROOT/man already in MANPATH\n"
	else
		# shellcheck disable=SC2016 # don't want to expand expression
		printf 'export MANPATH="${MY_ALTS_ROOT}/man:${MANPATH:-}"\n'
	fi
	if [ ! -d "${MY_ALTS_ROOT}/man" ]; then
		printf "# my-alternatives: warning: MY_ALTS_ROOT/man directory does not (yet) exist: %s\n" "${MY_ALTS_ROOT}/man" # STDOUT
	fi
	#
	# my-alternatives function
	# TODO Probably need a more portable technique for for the path check
	#
	cat <<-'FUNCTION'
		my-alternatives() {
		    command my-alternatives "$@"
		    local code=$?
		    if [[ $code -ge 125 ]]; then
		        export PATH="${PATH}"
		        code=$(( code - 125 ))
		    fi
		    return $code
		}
	FUNCTION
}

function help_config() {
	cat <<-'USAGE'
		usage: my-alternatives config <name>

		  Configures an alternative within the current MY_ALTS_ROOT.
		  Any <name> available via update-alternatives should be usable.

		this is meant to be a locally-scoped equivilent to:

		  $ update-alternatives --config <name>

		my-alternatives invokes the following command to get information for <name>:

		  $ update-alternatives --query <name>

		see 'my-alternatives help' to learn more about configuring MY_ALTS_ROOT

	USAGE
	exit 2
}

function do_config() {

	# No name argument
	#
	if [[ -z "${1:-}" ]]; then
		printf "my-alternatives: error: no name provided. see 'my-alternatives help config' for usage\n" >&2
		exit 1
	fi

	# No alt root defined
	#
	if [ -z "${MY_ALTS_ROOT:-}" ]; then
		printf "my-alternatives: error: MY_ALTS_ROOT not defined\n" >&2
		exit 2
	fi

	# Alt root not found
	#
	if [ ! -d "${MY_ALTS_ROOT}" ]; then
		printf "my-alternatives: error: MY_ALTS_ROOT folder not found: %s\n" "${MY_ALTS_ROOT}" >&2
		exit 2
	fi

	local alt_tmp
	if ! alt_tmp="$(command mktemp -q -t "my-alts-{$1}-query.XXXXXXXX")"; then
		printf "my-alternatives: error: error fetching alternative description: unable to create temp file\n" >&2
		exit 2
	fi

	if ! command update-alternatives --query "$1" >"${alt_tmp}"; then
		printf "my-alternatives: error: error fetching alternative description: error from update-alternatives\n" >&2
		rm "${alt_tmp}"
		exit 2
	fi

	parse_alt "${alt_tmp}"

	if [[ "${STATE}" != "MAYBE_ALT_START" && "${STATE}" != "MAYBE_ALT_SLAVE_ENTRY" ]]; then
		printf "my-alternatives: error: error parsing alternative description\n" >&2
		exit 2
	fi

	if [ -z "${TARGET_LINK}" ]; then
		printf "my-alternatives: error: unable to determine provided location\n" >&2
		exit 2
	fi

	SHALT_LINK_REL_PATH="$(get_my_alt_rel_path "${TARGET_LINK}")"
	SHALT_VALUE=
	SHALT_LINK="${MY_ALTS_ROOT}${SHALT_LINK_REL_PATH}"
	if [[ -e "${SHALT_LINK}" && -L "${SHALT_LINK}" ]]; then
		SHALT_VALUE=$(command readlink "${SHALT_LINK}")
	fi

	# declare -p  \
	# TARGET_NAME \
	# TARGET_LINK \
	# TARGET_SLAVE_NAMES \
	# TARGET_SLAVE_LINKS \
	# TARGET_BEST \
	# TARGET_BEST_PRIORITY \
	# TARGET_VALUE \
	# SHALT_LINK \
	# SHALT_VALUE \
	# ALT_VALUES \
	# MAX_VALUE_LEN \
	# ALT_PRIORITIES \
	# MAX_PRIORITY_LEN \
	# ALT_SLAVE_NAMES \
	# ALT_SLAVE_VALUES

	print_options

	local option path

	if [ -n "${SHALT_SELECTED}" ]; then
		printf "\nPress <enter> to keep the current choice[*], or type selection number: "
	else
		printf "\nType selection number: "
	fi

	command read -r option

	local path_modified=0
	if [[ "${option}" =~ ^[0-9]+$ && $option -gt 0 && $option -le ${#ALT_VALUES[@]} ]]; then
		option=$((option - 1)) # 1-based input but 0-based processing
		SHALT_VALUE="${ALT_VALUES[$option]}"
		if [[ "${TARGET_VALUE}" == "${SHALT_VALUE}" || -z "${SHALT_SELECTED}" || $option -ne $SHALT_SELECTED ]]; then
			if [ -e "${SHALT_VALUE}" ]; then
				# From here forward, path's *could* be modified
				#
				# Delete primary link
				#
				if [ -L "${SHALT_LINK}" ]; then
					command rm "${SHALT_LINK}"
					path_modified=125
				fi
				# Delete slave links
				#
				local slave_link my_alt_slave_link my_alt_link_dir
				for slave_link in "${TARGET_SLAVE_LINKS[@]}"; do
					slave_rel_path="$(get_my_alt_rel_path "${slave_link}")"
					if [ -n "${slave_rel_path}" ]; then
						my_alt_slave_link="${MY_ALTS_ROOT}${slave_rel_path}"
						if [ -L "${my_alt_slave_link}" ]; then
							command rm "${my_alt_slave_link}"
							path_modified=125
						fi
					fi
				done
				# Only process IF selected is NOT current system value
				#
				if [[ "${TARGET_VALUE}" != "${SHALT_VALUE}" ]]; then
					#
					# If we get here, we intend to create primary + slave links
					#

					# Warn if manpath not found
					#
					if ! command -v manpath &>/dev/null; then
						printf "my-alternatives: warning: command 'manpath' not found. alternative man pages may not be configured correctly.\n" >&2
					fi

					# Create primary link
					#
					my_alt_link_dir="${SHALT_LINK}"
					if [ -f "${SHALT_VALUE}" ]; then
						my_alt_link_dir="$(dirname "${my_alt_link_dir}")"
					elif [ ! -d "${SHALT_VALUE}" ]; then
						printf "my-alternatives: error: unable to determine provided location type (file, dir, etc): %s\n" "${SHALT_VALUE}" >&2
						exit $(( 2 + path_modified ))
					fi
					if ! command mkdir -p "${my_alt_link_dir}"; then
						printf "my-alternatives: error: unable to create parent folder for my-alternatives link: %s\n" "${SHALT_LINK}" >&2
						exit $(( 2 + path_modified ))
					fi
					# Link the file
					#
					command ln -s "${SHALT_VALUE}" "${SHALT_LINK}"
					path_modified=125
					if [[ "$(get_my_alt_rel_path "${SHALT_LINK}")" != "${SHALT_LINK_REL_PATH}" ]]; then
						printf "my-alternatives: warning: you may need to update paths in order to access my-alternatives file: \${MY_ALTS_ROOT}%s\n" "${SHALT_LINK_REL_PATH}" >&2
					fi
					# Create slave links
					#
					local i slave_link slave_link_dir slave_name slave_rel_path
					local slave_alt_names_str slave_alt_names slave_alt_values_str slave_alt_values
					i=0
					# declare -p i
					while [[ $i -lt ${#TARGET_SLAVE_NAMES[@]} ]]; do
						slave_name="${TARGET_SLAVE_NAMES[$i]}"
						slave_link="${TARGET_SLAVE_LINKS[$i]}"
						slave_rel_path="$(get_my_alt_rel_path "${slave_link}")"
						# declare -p slave_name slave_link slave_rel_path
						if [ -n "${slave_rel_path}" ]; then
							# shellcheck disable=SC2034 # Variable is used by reference
							slave_alt_names_str="${ALT_SLAVE_NAMES[$option]}"
							# shellcheck disable=SC2034 # Variable is used by reference
							slave_alt_values_str="${ALT_SLAVE_VALUES[$option]}"
							deserialize_array slave_alt_names_str slave_alt_names
							deserialize_array slave_alt_values_str slave_alt_values

							# declare -p slave_alt_names slave_alt_values

							# Find slave for name
							#
							local n slave_value
							slave_value=
							n=0
							while [[ $n -lt ${#slave_alt_names[@]} ]]; do
								if [[ "${slave_name}" == "${slave_alt_names[$n]}" ]]; then
									# Found it!
									#
									slave_value="${slave_alt_values[$n]}"
									break
								fi
								n=$((n + 1))
							done
							# Did we find a slave value?
							#
							if [[ -n "${slave_value}" ]]; then
								# Create slave link
								#
								my_alt_slave_link="${MY_ALTS_ROOT}${slave_rel_path}"
								slave_link_dir="${my_alt_slave_link}"
								if [ -f "${slave_value}" ]; then
									slave_link_dir="$(dirname "${slave_link_dir}")"
								elif [ ! -d "${slave_value}" ]; then
									printf "my-alternatives: error: unable to determine provided location type (file, dir, etc): %s\n" "${slave_value}" >&2
									exit $(( 2 + path_modified ))
								fi
								if ! command mkdir -p "${slave_link_dir}"; then
									printf "my-alternatives: warning: unable to create parent folder for my-alternatives link: %s\n - skipping" "${slave_link}" >&2
									continue
								fi
								# Link the file
								#
								command ln -s "${slave_value}" "${my_alt_slave_link}"
								path_modified=125
								if [[ "$(get_my_alt_rel_path "${my_alt_slave_link}")" != "${slave_rel_path}" ]]; then
									printf "my-alternatives: warning: you may need to update paths in order to access my-alternatives file: \${MY_ALTS_ROOT}%s\n" "${slave_rel_path}" >&2
								fi
							else
								printf "my-alternatives: warning: unable to determine slave value for %s\n" "${slave_name} - skipping" >&2
							fi
						else
							printf "my-alternatives: warning: Unable to determine type (bin/man/etc) for %s\n" "${slave_name} @ ${slave_link} - skipping" >&2
						fi
						i=$((i + 1))
					done
						printf "\nconfigured local alternative for %s: %s\n" "${1}" "${SHALT_VALUE}"
				else
					printf "\nreverted to system alternative for %s\n" "${1}"
				fi
			else
				printf "my-alternatives: error: path not found: %s\n" "${SHALT_VALUE}" >&2
				exit $(( 1 + path_modified ))
			fi
		fi
	fi
	return $(( 0 + path_modified ))
}

function print_options() {
	printf "There are %d choices for the alternative %s (providing \${MY_ALTS_ROOT}%s).\n" ${#ALT_VALUES[@]} "${TARGET_NAME}" "${SHALT_LINK_REL_PATH}"
	if [[ ${#ALT_VALUES[@]} -gt 0 ]]; then
		local i path priority status selected path_pad my_alt_selected
		path_pad=$(((((MAX_VALUE_LEN + 3) / 4) * 4) - 1))
		printf "\n"
		printf "%1s %-9s    %-${path_pad}s %-10s %s\n" " " "Selection" "Path" "Priority" "Status"
		printf "%s\n" "------------------------------------------------------------"
		SHALT_SELECTED=
		i=1
		while [[ $i -le ${#ALT_VALUES[@]} ]]; do
			selected=" "
			my_alt_selected=" "
			status=""
			path="${ALT_VALUES[${i} - 1]}"
			if [ ! -e "${path}" ]; then
				status="not found"
			elif [[ "${TARGET_VALUE}" == "${path}" ]]; then
				status="system value"
			fi
			priority="${ALT_PRIORITIES[${i} - 1]}"
			if [[ "${TARGET_VALUE}" == "${path}" ]]; then
				# shellcheck disable=SC2034 # Use if tracking update-alternative values
				ALT_SELECTED=$i
				if [[ "${TARGET_STATUS}" == "manual" ]]; then
					# shellcheck disable=SC2034 # Use if tracking update-alternative values
					selected="*"
				fi
			fi
			if [[ "${SHALT_VALUE}" == "${path}" ]]; then
				SHALT_SELECTED=$((i - 1)) # Adjust for 0-based check later
				my_alt_selected="*"
			fi
			printf "%1s %-9s    %-${path_pad}s  %-9s %s\n" "${my_alt_selected}" "${i}" "${path}" "${priority}" "${status}"
			i=$((i + 1))
		done
	fi
}

##
# parse_alt
#
# $1 = file to read from (can be process sub)
#
# example:
#
#    parse_alt <( update-alternatives --query pager )
#
function parse_alt() {
	STATE="NAME"
	# local lineno
	# lineno=0 # 1 on first use
	while IFS="" read -r LINE || [ -n "${LINE}" ]; do
		# ((lineno += 1))
		# echo "#LINE NO          : ${lineno}"
		# echo "#LINE TEXT        : '${LINE}'"
		# echo "#STATE            : ${STATE}"
		# echo "#STATES           : $(declare -p STATES)"
		# echo "#STATEMENT_INDENTS: $(declare -p STATEMENT_INDENTS)"
		# echo "#TEXT_INDENTS     : $(declare -p TEXT_INDENTS)"
		# echo "#PRINT_INDENTS    : $(declare -p PRINT_INDENTS)"
		# echo -e "#>> ----------------\n"
		state_"${STATE}" "${LINE}"
	done <"${1}"
}

NAME_REGEX="^Name: (.+)$"
function state_NAME() {
	if [[ "${1}" =~ $NAME_REGEX ]]; then
		TARGET_NAME="${BASH_REMATCH[1]}"
	else
		printf "unable to parse target name: %s\n" "${1}"
		exit 2
	fi
	STATE="LINK"
}

LINK_REGEX="^Link: (.+)$"
function state_LINK() {
	if [[ "${1}" =~ $LINK_REGEX ]]; then
		TARGET_LINK="${BASH_REMATCH[1]}"
	else
		printf "unable to parse target link: %s\n" "${1}"
		exit 2
	fi
	STATE="SLAVES_HEADER"
}

function state_SLAVES_HEADER() {
	if [[ ! "${1}" =~ ^Slaves:$ ]]; then
		printf "unable to parse target slaves header: %s\n" "${1}"
		exit 2
	fi
	STATE="SLAVE_ENTRY"
}

TARGET_SLAVE_NAMES=()
TARGET_SLAVE_LINKS=()
SLAVE_REGEX="^ ([^ ]+) (.+)$"
function state_SLAVE_ENTRY() {
	if [[ "${1}" =~ $SLAVE_REGEX ]]; then
		TARGET_SLAVE_NAMES+=("${BASH_REMATCH[1]}")
		TARGET_SLAVE_LINKS+=("${BASH_REMATCH[2]}")
		# Leave status unchanged
	else
		STATE="STATUS"
		state_"${STATE}" "${1}"
	fi
}

STATUS_REGEX="^Status: (.+)$"
function state_STATUS() {
	if [[ "${1}" =~ $STATUS_REGEX ]]; then
		TARGET_STATUS="${BASH_REMATCH[1]}"
	else
		printf "unable to parse target status: %s\n" "${1}"
		exit 2
	fi
	STATE="BEST"
}

BEST_REGEX="^Best: (.+)$"
function state_BEST() {
	if [[ "${1}" =~ $BEST_REGEX ]]; then
		# shellcheck disable=SC2034 # Use if tracking update-alternative values
		TARGET_BEST="${BASH_REMATCH[1]}"
	else
		printf "unable to parse target best: %s\n" "${1}"
		exit 2
	fi
	STATE="VALUE"
}

VALUE_REGEX="^Value: (.+)$"
function state_VALUE() {
	if [[ "${1}" =~ $VALUE_REGEX ]]; then
		TARGET_VALUE="${BASH_REMATCH[1]}"
	else
		printf "unable to parse target value: %s\n" "${1}"
		exit 2
	fi
	STATE="MAYBE_ALT_START"
}

function state_MAYBE_ALT_START() {
	if [[ "${1}" != "" ]]; then
		printf "unable to parse target alt blank: %s\n" "${1}"
		exit 2
	fi
	STATE="ALT_VALUE"
}

ALT_VALUES=()
MAX_VALUE_LEN=0
ALT_SLAVE_NAMES=()
ALT_SLAVE_VALUES=()
ALT_VALUE_REGEX="^Alternative: (.+)$"
function state_ALT_VALUE() {
	if [[ "${1}" =~ $ALT_VALUE_REGEX ]]; then
		ALT_VALUES+=("${BASH_REMATCH[1]}")
		if [[ ${#BASH_REMATCH[1]} -gt ${MAX_VALUE_LEN} ]]; then
			MAX_VALUE_LEN=${#BASH_REMATCH[1]}
		fi
		ALT_SLAVE_NAMES+=("")
		ALT_SLAVE_VALUES+=("")
	else
		printf "unable to parse alternative value: %s\n" "${1}"
		exit 2
	fi
	STATE="ALT_PRIORITY"
}

ALT_PRIORITIES=()
MAX_PRIORITY_LEN=0
ALT_PRIORITY_REGEX="^Priority: ([0-9]+)$"
function state_ALT_PRIORITY() {
	if [[ "${1}" =~ $ALT_PRIORITY_REGEX ]]; then
		ALT_PRIORITIES+=("${BASH_REMATCH[1]}")
		if [[ ${#BASH_REMATCH[1]} -gt ${MAX_PRIORITY_LEN} ]]; then
			MAX_PRIORITY_LEN=${#BASH_REMATCH[1]}
		fi
		if [[ "${ALT_VALUES[${#ALT_VALUES[@]} - 1]}" == "${TARGET_BEST}" ]]; then
			# shellcheck disable=SC2034 # Use if tracking update-alternatives values
			TARGET_BEST_PRIORITY="${BASH_REMATCH[1]}"
		fi
	else
		printf "unable to parse alternative priority: %s\n" "${1}"
		exit 2
	fi
	STATE="ALT_SLAVES_HEADER"
}

function state_ALT_SLAVES_HEADER() {
	if [[ ! "${1}" =~ ^Slaves:$ ]]; then
		printf "unable to parse alternative slaves header: %s\n" "${1}"
		exit 2
	fi
	STATE="MAYBE_ALT_SLAVE_ENTRY"
}

function state_MAYBE_ALT_SLAVE_ENTRY() {
	if [[ "${1}" =~ $SLAVE_REGEX ]]; then
		local idx slave_names_str slave_names slave_values_str slave_values
		idx=$((${#ALT_VALUES[@]} - 1))
		slave_names_str=${ALT_SLAVE_NAMES[$idx]}
		slave_values_str=${ALT_SLAVE_VALUES[$idx]}
		deserialize_array slave_names_str slave_names
		deserialize_array slave_values_str slave_values

		slave_names+=("${BASH_REMATCH[1]}")
		slave_values+=("${BASH_REMATCH[2]}")
		serialize_array slave_names slave_names_str
		serialize_array slave_values slave_values_str
		ALT_SLAVE_NAMES[$idx]="${slave_names_str}"
		ALT_SLAVE_VALUES[$idx]="${slave_values_str}"
		# Leave status unchanged
	else
		STATE="MAYBE_ALT_START"
		state_"${STATE}" "${1}"
	fi
}

##
# serialize_array
# Serializes a bash array to a string, with a configurable seperator.
#
# $1 = source varname ( contains array to be serialized )
# $2 = target varname ( will contian the serialized string )
# $3 = seperator ( optional, defaults to $'\x01' )
#
# example:
#
#    my_arry=( one "two three" four )
#    serialize_array my_array my_string '|'
#    declare -p my_string
#
# result:
#
#    declare -- my_string="one|two three|four"
#
function serialize_array() {
	declare -n _array="${1}" _str="${2}" # _array, _str => local reference vars
	local IFS="${3:-$'\x01'}"
	# shellcheck disable=SC2034 # Reference vars assumed used by caller
	_str="${_array[*]}" # * => join on IFS
}

##
# deserialize_array
# Deserializes a string into a bash array, with a configurable seperator.
#
# $1 = source varname ( contains string to be deserialized )
# $2 = target varname ( will contain the deserialized array )
# $3 = seperator ( optional, defaults to $'\x01' )
#
# example:
#
#    my_string="one|two three|four"
#    deserialize_array my_string my_array '|'
#    declare -p my_array
#
# result:
#
#    declare -a my_array=([0]="one" [1]="two three" [2]="four")
#
function deserialize_array() {
	IFS="${3:-$'\x01'}" read -r -a "${2}" <<<"${!1}" # -a => split on IFS
}

##
# is_dir_in_path
# Checks if the provided entry exists in the provided colon-separated list
#
# $1 = path ( or any colon-sepearated list )
# $2 = dir ( entry to look for )
#
# Returns 0 if found 1 otherwise
#
# exmaple:
#
#    is_dir_in_path "${PATH}" /usr/local/bin && echo YES || echo NO
#
function is_dir_in_path() {
	# 0 = success
	# Most likely to be in middle, least likely to match full path
	#
	[[ "$1" == *":$2:"* || "$1" == "$2:"* || "$1" == *":$2" || "$1" == "$2" ]] && return 0 || return 1
}

##
# $1 = file (assumed to represent a file ie last element removed for path checks)
#
function get_my_alt_rel_path() {
	local file path
	if [ "${1}" == "" ]; then
		printf ""
		return
	else
		file="$(basename "$1")"
		path="$(dirname "$1")"
		if [ "${file}" == "" ] || [ "${path}" == "." ] || [ "${path}" == "/" ]; then
			printf "%s" "$1"
			return
		fi
	fi
	# Check $PATH
	#
	if is_dir_in_path "${PATH}" "${path}"; then
		printf "/bin/%s" "${file}"
		return
	fi
	# Check manpath
	#
	if command -v manpath &>/dev/null; then
		local _manpath
		_manpath="$(command manpath 2>/dev/null)"
		while [ "${path}" != "." ] && [ "${path}" != "/" ]; do
			if is_dir_in_path "${_manpath}" "${path}"; then
				printf "/man/%s" "${file}"
				return
			fi
			file="$(command basename "${path}")/${file}"
			path="$(command dirname "${path}")"
		done
	fi
	# Unknown
	#
	printf "%s" "$1"
}

# Only process main logic if not being sourced (ie tested)
#
(return 0 2>/dev/null) || main "$@"

export PATH="${PATH}"
